{"ast":null,"code":"export function createStore(reducer, fn) {\n  let state; // state 就是用来存储公用数据的\n\n  let listeners = []; // 用来存储subscribe传进来的事件\n\n  let getState = function () {\n    //这个函数只是用来返回state的\n    return state && JSON.parse(JSON.stringify(state)); // 深拷贝不影响原state\n  };\n\n  let dispatch = function (action) {\n    // 用来触发reducer\n    console.log(action);\n    state = reducer(state, action);\n    console.log(\"====\", state); //发布\n    // 数据更新依次执行订阅的函数\n\n    listeners.forEach(item => {\n      item && item();\n    });\n  };\n\n  dispatch({}); // 第一次执行(初始化) 为了给私有变量state一个初始值\n  // 订阅函数\n\n  let subscribe = function (f) {\n    listeners.push(f); // 返回一个fn 在组件销毁的时候使用清除无用的事件\n\n    return () => {\n      // 过滤掉事件池中不需要执行的事件\n      listeners = listeners.filter(item => item !== f);\n    };\n  };\n\n  if (typeof fn === \"function\") {\n    return fn(createStore)(reducer); //执行整合middleware的fn 返回store对象\n  }\n\n  return {\n    getState,\n    dispatch,\n    subscribe\n  };\n} // 整合多个reducer 传给createStore\n\nexport function combineReducers(obj) {\n  // obj:{todo:todoReducer,color:colorReducer}\n  //state 之后通过dispatch触发reducer执行 将 此state 赋值给 createStore的state 就是redux的唯一状态对象\n  // 实参就是 state唯一状态对象\n  return function (state = {}, action) {\n    Object.keys(obj).forEach(item => {\n      // obj[item] todoReducer colorReducer\n      state[item] = obj[item](state[item], action);\n    });\n    return state;\n  };\n} // 整合多个中间件\n\nexport const compose = (...fns) => (...arg) => {\n  let first = fns.shift();\n  return fns.reduce((prev, cur) => {\n    return cur(prev);\n  }, first(...arg));\n};\nexport function applyMiddleware(...middleware) {\n  //middleware thunk\n  return function (createStore) {\n    return function (reducer) {\n      let store = createStore(reducer); //{getState,dispatch,subscribe}\n      // let  middle = middleware(store) //单个中间件\n\n      let middles = middleware.map(item => item(store));\n      console.log(\"====\", middles); // let temps = middles.map(item=>item(store.dispatch))\n      // console.log(222222,temps)\n      // let temp = middles[1](store.dispatch)\n      // temp 是一个新的dispatch\n\n      let temp = compose(...middles)(store.dispatch);\n      return { ...store,\n        dispatch: temp // 覆盖原来的dispatch\n\n      };\n    };\n  };\n}","map":{"version":3,"sources":["F:/react/learning/studyreact/src/day5/store/myredux.js"],"names":["createStore","reducer","fn","state","listeners","getState","JSON","parse","stringify","dispatch","action","console","log","forEach","item","subscribe","f","push","filter","combineReducers","obj","Object","keys","compose","fns","arg","first","shift","reduce","prev","cur","applyMiddleware","middleware","store","middles","map","temp"],"mappings":"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","sourcesContent":["export function createStore(reducer, fn) {\r\n  let state; // state 就是用来存储公用数据的\r\n  let listeners = []; // 用来存储subscribe传进来的事件\r\n  let getState = function () {\r\n    //这个函数只是用来返回state的\r\n    return state && JSON.parse(JSON.stringify(state)); // 深拷贝不影响原state\r\n  };\r\n  let dispatch = function (action) {\r\n    // 用来触发reducer\r\n    console.log(action);\r\n    state = reducer(state, action);\r\n    console.log(\"====\", state);\r\n    //发布\r\n    // 数据更新依次执行订阅的函数\r\n    listeners.forEach((item) => {\r\n      item && item();\r\n    });\r\n  };\r\n  dispatch({}); // 第一次执行(初始化) 为了给私有变量state一个初始值\r\n  // 订阅函数\r\n  let subscribe = function (f) {\r\n    listeners.push(f);\r\n    // 返回一个fn 在组件销毁的时候使用清除无用的事件\r\n    return () => {\r\n      // 过滤掉事件池中不需要执行的事件\r\n      listeners = listeners.filter((item) => item !== f);\r\n    };\r\n  };\r\n  if (typeof fn === \"function\") {\r\n    return fn(createStore)(reducer); //执行整合middleware的fn 返回store对象\r\n  }\r\n  return {\r\n    getState,\r\n    dispatch,\r\n    subscribe,\r\n  };\r\n}\r\n// 整合多个reducer 传给createStore\r\nexport function combineReducers(obj) {\r\n  // obj:{todo:todoReducer,color:colorReducer}\r\n  //state 之后通过dispatch触发reducer执行 将 此state 赋值给 createStore的state 就是redux的唯一状态对象\r\n  // 实参就是 state唯一状态对象\r\n  return function (state = {}, action) {\r\n    Object.keys(obj).forEach((item) => {\r\n      // obj[item] todoReducer colorReducer\r\n      state[item] = obj[item](state[item], action);\r\n    });\r\n    return state;\r\n  };\r\n}\r\n// 整合多个中间件\r\nexport const compose = (...fns) => (...arg) => {\r\n    let first = fns.shift()\r\n    return fns.reduce((prev,cur)=>{\r\n        return cur(prev)\r\n    },first(...arg))\r\n};\r\n\r\nexport function applyMiddleware(...middleware) {\r\n  //middleware thunk\r\n  return function (createStore) {\r\n    return function (reducer) {\r\n      let store = createStore(reducer); //{getState,dispatch,subscribe}\r\n      // let  middle = middleware(store) //单个中间件\r\n      let middles = middleware.map(item=>item(store));\r\n      console.log(\"====\", middles);\r\n      // let temps = middles.map(item=>item(store.dispatch))\r\n      // console.log(222222,temps)\r\n      // let temp = middles[1](store.dispatch)\r\n      // temp 是一个新的dispatch\r\n      let temp = compose(...middles)(store.dispatch);\r\n      return {\r\n        ...store,\r\n        dispatch: temp  // 覆盖原来的dispatch\r\n      };\r\n    };\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}